Tutorial
========

This chapter gives a gentle introduction to State Notation Language
(SNL).

A First Example
---------------

We start with a simple state machine ``volt_check`` that controls a
light switch depending on the value of a voltage measurement and
the internal state of the program. The following code fragment
defines the state machine::

  ss volt_check {
    state light_off {
      when (voltage > 5.0) {
        light = TRUE;
        pvPut(light);
      } state light_on
    }
    state light_on {
      when (voltage < 3.0) {
        light = FALSE;
        pvPut(light);
      } state light_off
    }
  }

At the top level we use the keyword ``ss`` to declare a *state set* named
``volt_check``. "State set" is SNL speak for state machine; it really is a
set of states, since the order in which the states are declared is largely
irrelevant. Inside the code block that follows, we define the *states* of
this state set, using the `state` keyword. There are two states here:
``light_off`` and ``light_on``. Inside each state, we define conditions
under which the program will enter another state, indicated by the keyword
``when``. The block following the condition contains *action statements* that
are executed when the condition fires.

In our example, in state ``light_off``, whenever the voltage exceeds a
value of 5.0, the light switch is turned on, and the internal state
changes to ``light_on``. In state ``light_on``, whenever the voltage is
or drops below 3.0, the light switch is turned off, and the internal
state changes to ``light_off``.

The following is a graphical representation of the above state machine:

.. blockdiag::

   blockdiag {
      orientation = portrait
      default_group_color = "#6BA81E"

      span_width = 180  // default value is 64
      span_height = 30  // default value is 40

      class start [shape = minidiamond, color = "#6BA81E", fontsize = 14]
      class state [shape = cloud, style = "1,2", height = 30, width = 100, color = "#6BA81E", fontsize = 14]
      class cond [shape = flowchart.condition, width = 80, height = 30]
      class actions [shape = flowchart.terminator, width = 120]
      class inner [style = "1,2"]

      start [class = start]
      start -> light_off
      group {
         light_off [class = state]
         v_above_5 [class = cond, label = "v > 5"]
         turn_on [class = actions, label = "light = TRUE;\npvPut(light);"]
         light_off -> v_above_5 -> turn_on [class = inner]
      }
      turn_on -> light_on
      group {
         light_on [class = state]
         v_below_3 [class = cond, label = "v < 3"]
         turn_off [class = actions, label = "light = FALSE;\npvPut(light);"]
         light_on -> v_below_3 -> turn_off [class = inner]
      }
      turn_off -> light_off
   }

Note that the output or action depends not only on the input or
condition, but also on the current state. For instance, an input
``voltage`` of 4.2 volts does not alone determine the output (``light``),
the current state matters, too.

As you can see, the SNL code is syntactically very similar to the C
language. Particularly, the syntax for variable declarations, expressions,
and statements are exactly as in C, albeit with a few minor restrictions,
and also some additions.

Variables
---------

As in C, variables must be declared before they can be used. The above example does not yet contain any variable declarations, so let's add them::

  float pv voltage = pv ("Input_voltage", monitor);
  int pv light = pv "Indicator_light";

This declares the two variables ``voltage``, which represents a measured
voltage, and ``light`` which controls a light switch. The `pv` marker in
the type says that these are not normal variables of type ``float`` and
``int``, respectively (which would behave exactly as C variables) but rather
so called /channels/. Channels are special variables that can be associated 
with EPICS process variables (PVs). The names of the PVs are given in the
initializer. The keyword "pv" is (re-)used here to distinguish it from the
normal way to initialize a variable to a constant value.

We also want the value of ``voltage`` to be updated automatically whenever
the PV changes its value. This is what the extra `monitor` flag in the
initializer is for.

So, whenever the value of the PV "Input_voltage" in the control system (the
EPICS database) changes, the value of ``voltage`` will likewise change. Note
however that this depends on the underlying system sending update messages
for the value in question. When and how often such updates are communicated
by the underlying system may depend on the configuration of the PV. For
instance if the PV "Input_voltage" is the VAL field of an ai (analog input)
record, then the value of the MDEL field of the same record specifies the
amount of change that the designer considers a "relevant" change; smaller
changes will not cause an event to be sent, and accordingly will not cause a
state change in the above program.

Built-in PV Functions
---------------------

In contrast to the `monitor` feature explained above, mutating the value of
a channel, e.g. via the C assignment operator as in::

  light = TRUE;

only changes the value as seen from inside the program. To make the value of
the PV change, too, the special built-in function `pvPut` must be called,
with the channel variable as argument, as in::

  pvPut(light);

Note that what actually gets passed to the function is, despite appearances,
not the *value* of the variable ``light`` (a float), but rather the channel
of type ``float pv``. The (simplified) type of `pvPut`::

   enum pvStat pvPut(void pv channel)

may make this clearer. Also note that channels are reference types, so in
general the function may modify it.

There are many more of these built-in functions, the `Reference` contains
detailed descriptions of each one. For now, let's keep to the basics; I'll
mention just one more built-in function: With `pvGet`, you can poll PVs
explicitly, instead of using `monitor`. That is, a statement such as ::

  pvGet(voltage);

has the effect of sending a get request to the PV "Input_voltage", waiting
for the response, and then updating the value of ``voltage`` with the new
value.

.. _A Complete Program:

A Complete Program
------------------

Here is what the complete program for our example looks like::

  program level_check

  float pv voltage = pv ("Input_voltage", monitor);
  int pv light = pv "Indicator_light";

  ss volt_check {
    state light_off {
      when (voltage > 5.0) {
        /* turn light on */
        light = TRUE;
        pvPut(light);
      } state light_on
    }

    state light_on {
      when (voltage < 5.0) {
        /* turn light off */
        light = FALSE;
        pvPut(light);
      } state light_off
    }
  }

Each program must start with the word `program`, followed by the name
of the program (an identifier)::

  program level_check

After that come global declarations and then one or more state sets.


Adding a Second State Set
-------------------------

We will now add a second state set to the previous example. This
new state set generates a changing value as its output (a triangle
function with amplitude 11).

First, we add the following lines to the declaration::

  float pv vout = pv "Output_voltage";
  float delta;

Next we add the following lines after the first state set::

  ss generate_voltage {
    state init {
      when () {
        vout = 0.0;
        pvPut(vout);
        delta = 0.2;
      } state ramp
    }
    state ramp {
      when (delay(0.1)) {
        if ((delta > 0.0 && vout >= 11.0) \|\|
          (delta < 0.0 && vout <= -11.0)) {
          delta = -delta; /* change direction */
        }
        vout += delta;
      } state ramp;
    }
  }

The above example exhibits several concepts. First, note that the
`transition` clause in state ``init`` contains an empty event
expression. This means unconditional execution of the transition. The
first state in each state set is always the initial state, so we give
it the name ``init``. From this first state there is an immediate
unconditional transition to the state ``ramp``, initializing some
variables during the transition. Note that the ``ramp`` state always
returns to itself. The structure of this state set is shown in the
following diagram:

.. blockdiag::

   blockdiag {
      orientation = portrait
      default_group_color = "#6BA81E"

      span_width = 180  // default value is 64
      span_height = 30  // default value is 40

      class start [shape = minidiamond, color = "#6BA81E", fontsize = 14]
      class state [shape = cloud, style = "1,2", height = 30, width = 100, color = "#6BA81E", fontsize = 14]
      class cond [shape = flowchart.condition, width = 80, height = 30]
      class actions [shape = flowchart.terminator, width = 120]
      class inner [style = "1,2"]

      start [class = start]
      start -> init
      group {
         init [class = state, label = "state init"]
         nil [class = cond, label = "TRUE"]
         set_vout [class = actions, height = 55, label = "vout = 0.0;\npvPut(vout);\ndelta = 0.2;\n"]
         init -> nil -> set_vout [class = inner]
      }
      set_vout -> ramp
      group {
         ramp [class = state, label = "state ramp"]
         delay [class = cond, label = "delay(0.1)", width = 100]
         repeat [class = actions, label = "...\nvout += delta;"]
         ramp -> delay -> repeat [class = inner]
      }
      repeat -> ramp
   }

The final concept introduced in the last example is the `delay` function.
This function returns a boolean that tells us whether the given time
interval has elapsed. The interval is given in seconds (as a floating point
value) and counts from the time the state was entered.

At this point, you may wish to try an example with the two state sets.
You can jump ahead and read parts of the Chapters `Compiling` and
`Using` to find out how.


Variable Initialization and Entry Blocks
----------------------------------------

Since version 2.1 it has become simpler to initialize variables: you
can use the same syntax as in C, i.e. initialize together with the
declaration::

  float vout = 0.0;
  float delta = 0.2;

which, by the way, can also be written as ::

  float vout = 0.0, delta = 0.2;

More complicated initialization (e.g. involving non-constant expressions or
side-effects) can be done using an `entry` block instead of using a separate
state::

  ss generate_voltage {
    state ramp {
      entry {
        pvPut(vout);
      }
      when (delay(0.1)) {
        ...
      } state ramp;
    }
  }

The actions in an entry block in a state declaration are executed whenever
the state is entered from a different state. In this case this means the ::

  pvPut(vout);

that appears inside the entry block will be executed only once when the
state is entered for the first time.


PV Names Using Program Parameters
---------------------------------

You can use program parameter substitution to parameterize the PV names
in your program. In our example we could say::

  float pv voltage = pv ("{unit}:Input_voltage", monitor);
  int pv light = pv "{unit}:Indicator_light";

The string within the curly braces is the name of a program parameter
and the whole thing (the name and the braces) are replaced with the
value of the parameter. For example, if the parameter "unit" has value
"DTL_6:CM_2", then the expanded PV name of ``voltage`` is
"DTL_6:CM_2:Input_voltage". See
`run time parameters` for more on program parameters (and
particularly how to give them values).


Data Types
----------

SNL data types are very similar to the ones you can use (and define) in C,
with a few minor restrictions. The most important one is that "pv" types are
limited to primitive types and arrays of them. This is because these are the
data types that EPICS `PV`\s can have. Another one is that *type synonyms*
(introduced in C with "typedef") are not allowed in SNL; when using a
typedef defined in some C library, you must prefix the type name with the
keyword "typename", so that the compiler knows that this is a type and not a
variable.

Further details can be found in the reference under `Types and
Declarations`.


Arrays and Structs of Channel Variables
---------------------------------------

Aggregation of variables into larger structures helps to give structure to
programs. In SNL, this is of course the same. Of particular interest for us
is that such structures can contain channel variables, too.

For instance, an array of four analog output channels, each assigned to its
own PV, can be declared as ::

  float pv Vout[4] = pv {
    "{unit}1",
    "{unit}2",
    "{unit}3",
    "{unit}4"
  };

As in C, you could program a loop over this array as in ::

  for (i = 0; i < 4; i++) {
    Vout[i] = 0.0;
    pvPut (Vout[i]);
  }

A subtlety here is the precedence of the "pv" marker in the declaration. In ::

  float pv Vout[4]

the ``[4]`` suffix binds stronger, so this is read as "Vout is an array of 4
pv of float". If, in constrast, you have a single PV, which has an array of
floats as its value, you must write this as ::

  float (pv Vout)[4]

which then reads "Vout is a pv of an array of 4 floats", and would be used
as in ::

  for (i = 0; i < 4; i++) {
    Vout[i] = 0.0;
  }
  pvPut (Vout); // a single pvPut for the whole array

Similarly, the monitor declaration may be either by individual
element::

  float pv Vin[4] = {
    pv ("{unit}1", monitor),
    pv ("{unit}2", monitor),
    pv ("{unit}3", monitor),
    pv ("{unit}4", monitor),
  };

or for all of them together::

  float pv Vout[4] = pv ({
    "{unit}1",
    "{unit}2",
    "{unit}3",
    "{unit}4"
  }, monitor);

So far we have been focusing on simple one-dimensional arrays. When you want
to aggregate channels of different types, defining a struct is the way to
go::

  struct PowerSupply {
    double pv setCur;
    double pv readCur;
    int pv statusBits[8];
  };

  struct PowerSupply ps[3];

This declares ps as an array of three PowerSupply structs, each of which has
one setpoint, one readback, and eight status bit channels. (Not all members must
be of a pv type, you can freely mix pv and non-pv members.)


Traditional Syntax for Channel Variable Configuration
-----------------------------------------------------

There is an alternative notation for assigning PV names to channel
variables. In earlier versions of the sequencer this was the only way, so
you might find this notation a lot in existing programs.

Let's say we have ::

  int pv x;

Then you can separately assign a PV name with ::

  assign x to "name_of_the_pv";

and declare that it should be monitored with ::

  monitor x;

PV initializers are more compact and avoid repeating the variable name,
while the traditional style is more explicit. It is largely a matter of
taste which you prefer.


Dynamic Assignment
------------------

You may dynamically assign or re-assign variables to PVs during the program
execution as follows::

  float pv Xmotor;
  assign Xmotor to "Motor_A_2";
  ...
  sprintf (pvName, "Motor_%s_%d", snum, mnum)
  pvAssign (Xmotor[i], pvName);

If you pass an empty string, the variable gets de-assigned::

  pvAssign(Xmotor, "");

In `safe mode` this means that it becomes an anonymous PV that is only visible
inside the program, whereas in traditional mode it will be treated as if it
were no channel variable (i.e. as if it had no pv marker in its type).

The `pvAssigned` function returns whether a channel is currently assigned to
a PV::

  if (pvAssigned(Xmotor[0])) ...

The number of currently assigned variables in the whole program is returned
by the `pvAssignCount` function::

  numAssigned = pvAssignCount();

The following inequality will always hold::

  pvConnectCount() <= pvAssignCount() <= pvChannelCount()

After assigning a variable, you should wait for it to connect
before using it (although it is OK to monitor it). See
`Connection Management`_.


Status of Channels
------------------

Channel variables have an associated status, severity and time stamp.
You can obtain these with the `pvStatus`, `pvSeverity`
and `pvTimeStamp` functions. For example::

  when (pvStatus(x_motor) != pvStatOK) {
    printf("X motor status=%d, severity=%d, timestamp=%d\\n",
      pvStatus(x_motor), pvSeverity(x_motor),
      pvTimeStamp(x_motor).secPastEpoch);
  }


.. _EventFlags:

Synchronizing State Sets with Event Flags
-----------------------------------------

Different state sets within the same program are run as concurrent threads;
and the whole programs runs concurrently to the "rest of the world", i.e.
the control system that provides the PVs.

To synchronize state sets with each other, and with externally issued events
on process variables, *event flags* can be used. Event flags are boolean
variables whose value be accessed only with the four built-in functions
`efSet`, `efClear`, `efTest`, and `efTestAndClear`.

For instance, one state set will set an event flag, and another state set
will test that event flag within a `transition` clause.

An event flag can be associated with one or more monitored channel
variables. In this case, whenever a monitor for one of the channels is
delivered, the corresponding event flag is set. This is particularly useful
when some action or state change must occur for any change in a set of
channels.

The following example shows a state set that forces a low limit to be
less than or equal to a high limit. The first `transition` clause fires when
the low limit changes and someone has attempted to set it above the high
limit. The second `transition` clause fires when the opposite situation
occurs. 

.. todo:: this works, too

  ::

    struct Limit {
      double pv limit;
      evflag flag;
    };

    struct Limits {
      struct Limit low;
      struct Limit high;
    };

    struct Limits limits = {
      { pv ("demo:loLimit", monitor, sync limits.low.flag), 0 },
      { pv ("demo:hiLimit", monitor, sync limits.low.flag), 0 },
    };

::

  evflag loFlag;
  double pv loLimit = pv ("demo:loLimit", monitor, sync loFlag);

  evflag hiFlag;
  double pv hiLimit = pv ("demo:hiLimit", monitor, sync hiFlag);

  ss limit {
    state START {
      when ( efTestAndClear( loFlag ) && loLimit > hiLimit ) {
        hiLimit = loLimit;
        pvPut( hiLimit );
      } state START

      when ( efTestAndClear( hiFlag ) && hiLimit < loLimit ) {
        loLimit = hiLimit;
        pvPut( loLimit );
      } state START
    }
  }

You can synchronize many different channel to the same event flag, but each
channel can only be `sync`'ed to one event flag.

.. _QueuingMonitors:

Queuing Monitors
----------------

Neither testing the value of a monitored channel in a `transition`
clause nor associating the channel with an event flag and then testing
the event flag can guarantee that a program is aware of all
monitors posted on the channel. Often this doesn't matter, but
sometimes it does. For example, a variable may transition to 1 and
then back to 0 to indicate that a command is active and has completed.
If these transitions occur in rapid succession, then the program might "see"
only one event, with the (unchanged) value 0.

Queues are a way to make sure that no events are lost (assuming the queue
size is large enough to avoid overflow). To associate a queue with a channel
variable, you can use a pv initializer::

  int pv cmd = pv ("{unit}:cmd", monitor, syncq 10);

This allocates a queue of size 10 for the channel (size means the maximum
number of events that can be stored for this channel). The `pvGetQ` function
retrieves and removes the head of queue, if any, returning FALSE if the
queue is empty and TRUE otherwise.

Here is an example::

  int pv command = pv "commandVar";

  int pv active = pv ("activeVar", monitor, syncq 2);

  ss queue {
    state start {
      entry {
        pvFlushQ( active );
        command = 1;
        pvPut( command );
      }
      when ( pvGetQ( active ) && active ) {
      } state high
    }
    state high {
      when ( pvGetQ( active ) && !active ) {
      } state done
    }
    state done {
      /* ... */
    }
  }

This program sets the ``command`` variable to 1 and then waits for the
``active`` flag to change as a result. When the ``active`` flag goes back to
0 we know the operation has completed.

Note the use of `pvFlushQ` to clear the queue before sending the command.
This is recommended, since the channel might change due to external factors
before our command is issued.

It is allowed to use the same queue for more than one channel variable,
provided they all have the same value type. This is currently only possible
if the channels are array elements.

.. todo:: check if the implementation conforms to the above

Asynchronous Use of pvGet
-------------------------

Normally the `pvGet` operation acts snychronously, that is, it waits until a
response from the PV has arrived before returning to the caller. It is
possible to change this default behaviour by specifying the `+a` compiler
flag (see `CompilerOptions`). In this case the operation will only be
initiated and the function returns immediately. To test for completion use
the function `pvGetComplete`.

`pvGet` also accepts an optional ``SYNC`` or ``ASYNC`` argument, which
overrides the `+a` compiler flag (or its absence). For example, ::

  pvGet( initActive[i], ASYNC );

will make the operation asynchronous, regardless of any compiler flags.

.. _AsynchronousUseofpvPut:

Asynchronous Use of pvPut
-------------------------

The situation is similar, though not identical, with `pvPut`.

Normally `pvPut` is a "fire and forget" operation without any provisions for
testing if and when it completed successfully. However, this
behaviour can be modified by passing an optional ``SYNC`` or ``ASYNC``
argument. With ``SYNC``, the call blocks until the operation is complete,
while with ``ASYNC`` the call returns immediately. In the latter case,
`pvPutComplete` tells you whether the operation completed.

For example, ::

  pvPut(init[i], SYNC);

will block until the put operation to the PV behind ``init[i]`` (and all the
processing resulting from it) is complete, while ::

  pvPut(init[i], ASYNC);

does not block and instead lets you test completion explicitly, e.g. ::

  when(pvPutComplete(init[i])) {
    ...
  }

Note that `pvPutComplete` can only be used with single PVs. Testing
completion for multiple PVs in a multi-PV array can be done with
`pvArrayPutComplete` as in the following example ::

  #define N 3
  long init[N];
  seqBool done[N]; /* used in the modified example below */
  assign init to {"ss1:init", "ss2:init", "ss3:init"};

  state inactive {
    when () {
      for ( i = 0; i < N; i++ ) {
        init[i] = 1;
        pvPut( init[i], ASYNC );
      }
    } state active
  }

  state active {
    when ( pvArrayPutComplete( init ) ) {
    } state done

    when ( delay( 10.0 ) ) {
    } state timeout
  }

`pvArrayPutComplete` accepts optional arguments to tweak its behaviour.
For instance, the following could be inserted
before the first `transition` clause in the ``active`` state above.
The ``TRUE`` argument causes `pvPutComplete` to return
``TRUE`` when any command completed (rather than only when all
commands complete). The ``done`` argument is the address of a ``seqBool``
array of the same size as ``init`` ; its elements are set to ``FALSE`` for
puts that are not yet complete and to ``TRUE`` for puts that are complete.

::

  when ( pvPutComplete( init, TRUE, done ) ) {
    for ( i = 0; i < N; i++ )
      printf( " %ld", done[i] );
    printf( "\n" );
  } state active

Connection Management
---------------------

Normally all state sets in a program wait until all channel
variables are connected to their PVs. However, with the `-c` compiler flag,
execution begins while the connections are being established. The
program can test for each variable's connection status with the
`pvConnected` routine, or it can test for all variables
connected with the following comparison (if not using dynamic
assignment, see `Dynamic Assignment`_, `pvAssignCount` will be
the same as `pvChannelCount`)::

  pvConnectCount() == pvAssignCount()

These routines are described in `BuiltinFunctions`. If a variable
disconnects or re-connects during execution of a program, the
sequencer updates the connection status appropriately; this can be
tested in a `transition` clause, as in::

  when (pvConnectCount() < pvAssignCount()) {
  } state disconnected

When using dynamic assignment, you should wait for the newly
assigned variables to connect, as in::

  when (pvConnectCount() == pvAssignCount()) {
  } state connected

  when (delay(10)) {
  } state connect_timeout

The connection status of a single channel variable can be tested with the
`pvConnected` function, for instance inside a `when` condition. If you also
want to wait for an initial monitor event, you can use an event flag (see
`Synchronizing State Sets with Event Flags`_).

Multiple Instances and Reentrant Mode
-------------------------------------

Occasionally you will create a program that can be used in multiple
instances, typically using different program parameters for the different
instances. If these instances run inside the same address space, then the
generated code must be made reentrant using the `+r` compiler flag. With
this flag all global and stateset local variables are declared in a big
struct and allocated dynamically at run time; otherwise they are declared
one by one as static C variables.

Process Variable Element Count
------------------------------

Channel variables may be assigned to array valued PVs. Requests for such
channels assume the array size for the element count. However, if the PV has
a smaller count than the array size, the smaller number is used for all
requests. This count is available via the `pvCount` function. The following
example illustrates this::

  float wf[2000];
  assign wf to "{unit}:CavField.FVAL";
  int LthWF;
  ...
  LthWF = pvCount(wf);
  for (i = 0; i < LthWF; i++) {
    ...
  }
  pvPut(wf);
  ...

What's Happening at Run Time
----------------------------

At run time the sequencer blocks until something "interesting" occurs, where
"interesting" means things like receiving a monitor from a PV used in a
`transition` clause, an event flag changing state, or a delay timer
expiring. See section `transitions` in the `Reference` for a
detailed list.

The sequencer then scans the list of `transition` statements for the
current state and evaluates each expression in turn. If a `transition`
expression evaluates to non-zero the actions within that `transition` block
are executed and the sequencer enters the state specified by that
`transition` statement. The sequencer then blocks again waiting for
something "interesting" to happen.

Note, however, that whenever a new state is entered, the corresponding
`transition` conditions for that state are evaluated once without first
waiting for events.

.. _safe mode tutorial:

Safe Mode
---------

.. versionadded:: 2.1

SNL code can be interpreted in *safe mode*. This must be enabled with the
`+s` option, because it changes the way variables are handled and is thus
not fully backwards compatible. It should, however, be easy to adapt
existing programs to safe mode by making communication between state sets
explicit. New programs should no longer use the traditional unsafe mode.

Rationale
^^^^^^^^^

In the traditional (unsafe) mode, variables are *not* protected against
access from concurrently running threads. Concurrent access to SNL
variables was introduced in version 2.0, when implementation of the PV
layer switched from the old single threaded CA mode ("preemptive
callbacks disabled") to the multi-threaded mode ("preemptive callbacks
enabled") in order to support more than one state set per program. This
could result in data corruption for variables that are not read and written
atomically, the details of which are architecture and compiler dependent
(i.e. plain ``int`` is typically atomic, whereas double is problematic on
some, string and arrays on almost all architectures/compilers). Even for
plain ``int`` variables, read-modify-write cycles (like ``v++``) cannot be
guaranteed to have any consistent result. Furthermore, `condition`\s that have
been met inside a `transition` clause cannot be relied upon to still hold
inside the associated action block.

Concurrent access to SNL variables happens when

* multiple state sets access the same variable, or
* variables are updated from the PV layer due to monitors
  and asynchronous get operations.

While it is possible to avoid the first case by careful coding (using e.g.
event flags for synchronization) it is not possible to guard against the
second case as these events can interrupt action statements at any time.

One of the reasons SNL programs have mostly worked in spite of this is
that due to the standard CA thread priorities the callback thread does not
interrupt the state set threads. Furthermore (and contrary to what many
people believe) the VxWorks scheduler does not normally serve threads with
equal priority in a round-robin (time-sliced) fashion; instead each thread
keeps running until it gets interrupted by a higher priority thread or
until it blocks on a semaphore.

However, RTEMS does time-share threads at the same priority, while Linux and
Windows may or may not honor thread priorities, depending on the system
configuration. Most importantly, priorities should only be used to improve
latency for certain operations (at the cost of others) and never should be
relied upon for program correctness.

Safe mode solves all these problems by changing the way variables,
particularly global variables, are interpreted.

How it Works
^^^^^^^^^^^^

In safe mode, all variables
--except event flags-- are interpreted as if they were *local to the state
set*. This means that setting a variable (even a global variable) in one
state set does *not* automatically change its value as seen by other state
sets. State sets are effectively isolated against each other, and all
communication between them must be explicit. They are also isolated against
updates by callbacks from the PV layer except at those points where they
don't do anything i.e. when they wait for events in a `transition` clause.
In safe mode, variable values get updated right before the `condition`\s are
evaluated, or when explicitly calling synchronization functions like
`pvGetComplete` or `pvGet` (the latter only if called in
synchronous mode), as well as `efTest` and `efTestAndClear`.
The documentation for the built-in functions explains the details.

For instance, with the declaration ::

   int var;
   assign var;

the action statement ::

   pvPut(var)

makes the value of ``var`` available to other state sets. They will,
however, not see the new value until they issue either a (synchronous)
`pvGet`, or the variable is declared as monitored and state
change `condition`\s are evaluated.

The action ::

   pvGet(var, SYNC)

updates ``var`` immediately with whatever has been written to it
previously via `pvPut` by some other state set. Whereas ::

   pvGet(var, ASYNC)

has no immediate effect on the variable ``var``. Instead, ``var``
will be updated only if the code calls `pvGetComplete`
(and it returns `true`).

.. todo::

   Also when state change `condition`\s are evaluated the next time?

.. note:: This behaviour is exactly the same as with external PVs.

.. note:: Using `SYNC <compType>` or `ASYNC <compType>` with anonymous PVs is not very
   useful since all operations complete immediately.


Common Pitfalls and Misconceptions
----------------------------------

The delay function does not block
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

A common misconception among new SNL programmers is that the sequencer
somehow blocks inside the `delay` function within `transition`
statements. This interpretation of the `delay` function is
incorrect but understandable given the name. The `delay` function
does not block at all, it merely compares its argument with a timer that
is reset whenever the state is entered (from the same or another state),
and then returns the result (a boolean value). Any blocking (in case the
returned value is FALSE and no other condition fires) is done outside of
the `delay` function by the run time system. You might want to
think of the operation as ``elapsed(s)`` rather than ``delay(s)``.

If your action statements have any sort of polling loops or calls to
``epicsThreadSleep`` you should reconsider your design. The presence
of such operations is a strong indication that you're not using the
sequencer as intended. Use of functions such as ``epicsThreadSleep`` can
make sense in certain sitations, but in most cases it is better to
wait using a `when` condition with a call to `delay`. The reason for this is
that this easily allows you to extend it with other conditions your program
might want to respond to, such as the user hitting an "abort" button.

Using pvPut and monitor in the same state set
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

Let's say you have a channel variable x that is monitored, and this code
fragment::

  state one {
    when () {
      x = 1;
      pvPut(x);
      x++;
    } state two
  }
  state two {
    when (x > 1) {
      do_something();
    }
    when (x <= 1) {
      do_something_else();
    }
  }

This pattern is hazardous in a number of ways. What exactly happens here
depends on whether you are using `safe mode` or not.

Assuming traditional (unsafe) mode, it is unpredictable which branch in
state ``two`` will be taken. The ``pvPut(x)`` might cause a monitor event to
be posted by the PV that was assigned to ``x``. This event will change ``x``
back to ``1`` whenever it arrives. This might happen at any time in between
the ``pvPut(x)`` and the testing of the conditions. It could even interrupt
in the middle of the ``x++`` operation. As a result, this code behaves in
conpletely unpredictable ways, depending on the timing of the pvPut-monitor
round-trip.

In `safe mode` things are slightly better: the only point where the event can
lead to an update of the variable is *right before* evaluation of the
conditions. However, it is still undetermined which branch will be taken.

You might be tempted to test your code and find that "it works", in the
sense that the behavior you see appears to consistently chose one of the two
branches, perhaps after adding some `delay`\s to the conditions. But this
impression is **misleading**, since what actually happens depends on details
of thread scheduling and priorities and a host of other timing factors, some
of which are very hard to control such as network or system load.

If you cannot avoid using pvPut for a monitored variable, then you should at
least

#. use `safe mode`, *and*

#. make sure any change you make to the variable gets published (using
   `pvPut`, for named channels with ``SYNC`` option) before you leave the
   current action block.

However, the ultimate solution is to use different channel variables for
input and output; you can still assign them to the same PV.
